#include <cstdlib>
#include <iostream>

#include <arrow/flight/client.h>
#include <arrow/flight/sql/client.h>
#include <arrow/table.h>

#include "arrow/flight/server.h"
// #include "arrow/io/test_common.h"
// #include "arrow/testing/json_integration.h"
#include "arrow/util/logging.h"

#include "sqlite/sqlite_server.h"

namespace flight = arrow::flight;
namespace flightsql = arrow::flight::sql;

int port = 31337;

arrow::Status RunServer() {
    ARROW_ASSIGN_OR_RAISE(auto location,
                            arrow::flight::Location::ForGrpcTcp("0.0.0.0", port));
    arrow::flight::FlightServerOptions options(location);

    std::shared_ptr<arrow::flight::sql::sqlite::SQLiteFlightSqlServer> server;
    ARROW_ASSIGN_OR_RAISE(server,
                            arrow::flight::sql::sqlite::SQLiteFlightSqlServer::Create())

    ARROW_CHECK_OK(server->Init(options));
    // Exit with a clean error code (0) on SIGTERM
    ARROW_CHECK_OK(server->SetShutdownOnSignals({SIGTERM}));

    std::cout << "Server listening on localhost:" << server->port() << std::endl;
    ARROW_CHECK_OK(server->Serve());

    return arrow::Status::OK();
}

arrow::Status RunClient() {
    ARROW_ASSIGN_OR_RAISE(auto location,
                            flight::Location::ForGrpcTcp("localhost", port));
    std::cout << "Connecting to " << location.ToString() << std::endl;

    const std::string kQuery = "SELECT 1";

    // Set up the Flight SQL client
    std::unique_ptr<flight::FlightClient> flight_client;
    ARROW_ASSIGN_OR_RAISE(flight_client, flight::FlightClient::Connect(location));
    std::unique_ptr<flightsql::FlightSqlClient> client(
        new flightsql::FlightSqlClient(std::move(flight_client)));

    flight::FlightCallOptions call_options;

    // Execute the query, getting a FlightInfo describing how to fetch the results
    std::cout << "Executing query: '" << kQuery << "'" << std::endl;
    ARROW_ASSIGN_OR_RAISE(std::unique_ptr<flight::FlightInfo> flight_info,
                            client->Execute(call_options, kQuery));

    // Fetch each partition sequentially (though this can be done in parallel)
    for (const flight::FlightEndpoint& endpoint : flight_info->endpoints()) {
        // Here we assume each partition is on the same server we originally queried, but this
        // isn't true in general: the server may split the query results between multiple
        // other servers, which we would have to connect to.

        // The "ticket" in the endpoint is opaque to the client. The server uses it to
        // identify which part of the query results to return.
        ARROW_ASSIGN_OR_RAISE(auto stream, client->DoGet(call_options, endpoint.ticket));
        // Read all results into an Arrow Table, though we can iteratively process record
        // batches as they arrive as well
        ARROW_ASSIGN_OR_RAISE(auto table, stream->ToTable());
        std::cout << "Read one chunk:" << std::endl;
        std::cout << table->ToString() << std::endl;
    }

    return arrow::Status::OK();
}

int main(int argc, char** argv) {
    auto statusServer = RunServer();
    if (!statusServer.ok()) {
        std::cerr << statusServer.ToString() << std::endl;
        return EXIT_FAILURE;
    }

    auto statusClient = RunClient();
    if (!statusClient.ok()) {
        std::cerr << statusClient.ToString() << std::endl;
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}